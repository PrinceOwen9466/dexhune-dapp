/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
	BaseContract,
	BigNumberish,
	BytesLike,
	FunctionFragment,
	Result,
	Interface,
	EventFragment,
	AddressLike,
	ContractRunner,
	ContractMethod,
	Listener,
} from "ethers";
import type {
	TypedContractEvent,
	TypedDeferredTopicFilter,
	TypedEventLog,
	TypedLogDescription,
	TypedListener,
	TypedContractMethod,
} from "../common";

export declare namespace DexhuneExchangeBase {
	export type OrderStruct = {
		makerAddr: AddressLike;
		tokenAddr: AddressLike;
		orderType: boolean;
		created: BigNumberish;
		price: BigNumberish;
		principal: BigNumberish;
		pending: BigNumberish;
	};

	export type OrderStructOutput = [
		makerAddr: string,
		tokenAddr: string,
		orderType: boolean,
		created: bigint,
		price: bigint,
		principal: bigint,
		pending: bigint
	] & {
		makerAddr: string;
		tokenAddr: string;
		orderType: boolean;
		created: bigint;
		price: bigint;
		principal: bigint;
		pending: bigint;
	};

	export type TokenDataModelStruct = {
		tokenNo: BigNumberish;
		name: string;
		sym: string;
		addr: AddressLike;
		parityAddr: AddressLike;
		reward: BigNumberish;
		rewardThreshold: BigNumberish;
		scheme: BigNumberish;
		price: BigNumberish;
		orders: BigNumberish;
	};

	export type TokenDataModelStructOutput = [
		tokenNo: bigint,
		name: string,
		sym: string,
		addr: string,
		parityAddr: string,
		reward: bigint,
		rewardThreshold: bigint,
		scheme: bigint,
		price: bigint,
		orders: bigint
	] & {
		tokenNo: bigint;
		name: string;
		sym: string;
		addr: string;
		parityAddr: string;
		reward: bigint;
		rewardThreshold: bigint;
		scheme: bigint;
		price: bigint;
		orders: bigint;
	};
}

export interface DexhuneExchangeInterface extends Interface {
	getFunction(
		nameOrSignature:
			| "assignPriceDAO"
			| "clearOrders"
			| "createBuyOrder"
			| "createSellOrder"
			| "deposit"
			| "depositToken"
			| "depositTokenFrom"
			| "getBalance"
			| "listParityToken"
			| "listToken"
			| "listingCost"
			| "orders"
			| "owner"
			| "queryBalance"
			| "settleOrders"
			| "takeBuyOrder"
			| "takeSellOrder"
			| "transferOwnership"
			| "updateTokenBalance"
			| "viewOrder"
			| "viewOrderByMaker"
			| "viewOrderByToken"
			| "viewPrice"
			| "viewToken"
			| "viewTokenByIndex"
	): FunctionFragment;

	getEvent(
		nameOrSignatureOrTopic:
			| "AVAXTransferred"
			| "AssignedPriceDAO"
			| "OrderCreated"
			| "OrderReverted"
			| "OrderSettled"
			| "OrderTaken"
			| "TokenListed"
			| "TokenTransferred"
			| "TransferredOwnership"
	): EventFragment;

	encodeFunctionData(
		functionFragment: "assignPriceDAO",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "clearOrders",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "createBuyOrder",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "createSellOrder",
		values: [AddressLike, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "deposit",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "depositToken",
		values: [AddressLike, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "depositTokenFrom",
		values: [AddressLike, AddressLike, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "getBalance",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "listParityToken",
		values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "listToken",
		values: [AddressLike, BigNumberish, BigNumberish, string]
	): string;
	encodeFunctionData(
		functionFragment: "listingCost",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "orders",
		values: [BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "owner", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "queryBalance",
		values: [AddressLike, boolean]
	): string;
	encodeFunctionData(
		functionFragment: "settleOrders",
		values: [AddressLike, boolean]
	): string;
	encodeFunctionData(
		functionFragment: "takeBuyOrder",
		values: [AddressLike, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "takeSellOrder",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "transferOwnership",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "updateTokenBalance",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "viewOrder",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "viewOrderByMaker",
		values: [AddressLike, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "viewOrderByToken",
		values: [AddressLike, BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "viewPrice", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "viewToken",
		values: [AddressLike]
	): string;
	encodeFunctionData(
		functionFragment: "viewTokenByIndex",
		values: [BigNumberish]
	): string;

	decodeFunctionResult(
		functionFragment: "assignPriceDAO",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "clearOrders",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "createBuyOrder",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "createSellOrder",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "depositToken",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "depositTokenFrom",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "getBalance", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "listParityToken",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "listToken", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "listingCost",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "orders", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "queryBalance",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "settleOrders",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "takeBuyOrder",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "takeSellOrder",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "transferOwnership",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "updateTokenBalance",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "viewOrder", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "viewOrderByMaker",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "viewOrderByToken",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "viewPrice", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "viewToken", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "viewTokenByIndex",
		data: BytesLike
	): Result;
}

export namespace AVAXTransferredEvent {
	export type InputTuple = [amount: BigNumberish, targetAddr: AddressLike];
	export type OutputTuple = [amount: bigint, targetAddr: string];
	export interface OutputObject {
		amount: bigint;
		targetAddr: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace AssignedPriceDAOEvent {
	export type InputTuple = [addr: AddressLike];
	export type OutputTuple = [addr: string];
	export interface OutputObject {
		addr: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderCreatedEvent {
	export type InputTuple = [
		index: BigNumberish,
		orderType: boolean,
		tokenAddr: AddressLike,
		amount: BigNumberish,
		price: BigNumberish
	];
	export type OutputTuple = [
		index: bigint,
		orderType: boolean,
		tokenAddr: string,
		amount: bigint,
		price: bigint
	];
	export interface OutputObject {
		index: bigint;
		orderType: boolean;
		tokenAddr: string;
		amount: bigint;
		price: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderRevertedEvent {
	export type InputTuple = [
		index: BigNumberish,
		orderType: boolean,
		maker: AddressLike
	];
	export type OutputTuple = [index: bigint, orderType: boolean, maker: string];
	export interface OutputObject {
		index: bigint;
		orderType: boolean;
		maker: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderSettledEvent {
	export type InputTuple = [
		index: BigNumberish,
		orderType: boolean,
		maker: AddressLike,
		isPartial: boolean
	];
	export type OutputTuple = [
		index: bigint,
		orderType: boolean,
		maker: string,
		isPartial: boolean
	];
	export interface OutputObject {
		index: bigint;
		orderType: boolean;
		maker: string;
		isPartial: boolean;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace OrderTakenEvent {
	export type InputTuple = [
		index: BigNumberish,
		orderType: boolean,
		maker: AddressLike,
		taker: AddressLike,
		token: AddressLike,
		amount: BigNumberish,
		isPartial: boolean
	];
	export type OutputTuple = [
		index: bigint,
		orderType: boolean,
		maker: string,
		taker: string,
		token: string,
		amount: bigint,
		isPartial: boolean
	];
	export interface OutputObject {
		index: bigint;
		orderType: boolean;
		maker: string;
		taker: string;
		token: string;
		amount: bigint;
		isPartial: boolean;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenListedEvent {
	export type InputTuple = [
		name: string,
		symbol: string,
		pricingScheme: BigNumberish,
		addr: AddressLike,
		index: BigNumberish
	];
	export type OutputTuple = [
		name: string,
		symbol: string,
		pricingScheme: bigint,
		addr: string,
		index: bigint
	];
	export interface OutputObject {
		name: string;
		symbol: string;
		pricingScheme: bigint;
		addr: string;
		index: bigint;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenTransferredEvent {
	export type InputTuple = [
		amount: BigNumberish,
		targetAddr: AddressLike,
		tokenAddr: AddressLike
	];
	export type OutputTuple = [
		amount: bigint,
		targetAddr: string,
		tokenAddr: string
	];
	export interface OutputObject {
		amount: bigint;
		targetAddr: string;
		tokenAddr: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferredOwnershipEvent {
	export type InputTuple = [oldOwner: AddressLike, newOwner: AddressLike];
	export type OutputTuple = [oldOwner: string, newOwner: string];
	export interface OutputObject {
		oldOwner: string;
		newOwner: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export interface DexhuneExchange extends BaseContract {
	connect(runner?: ContractRunner | null): DexhuneExchange;
	waitForDeployment(): Promise<this>;

	interface: DexhuneExchangeInterface;

	queryFilter<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined
	): Promise<Array<TypedEventLog<TCEvent>>>;
	queryFilter<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined
	): Promise<Array<TypedEventLog<TCEvent>>>;

	on<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>
	): Promise<this>;
	on<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>
	): Promise<this>;

	once<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>
	): Promise<this>;
	once<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>
	): Promise<this>;

	listeners<TCEvent extends TypedContractEvent>(
		event: TCEvent
	): Promise<Array<TypedListener<TCEvent>>>;
	listeners(eventName?: string): Promise<Array<Listener>>;
	removeAllListeners<TCEvent extends TypedContractEvent>(
		event?: TCEvent
	): Promise<this>;

	assignPriceDAO: TypedContractMethod<
		[addr: AddressLike],
		[void],
		"nonpayable"
	>;

	clearOrders: TypedContractMethod<[], [void], "nonpayable">;

	createBuyOrder: TypedContractMethod<
		[tokenAddr: AddressLike],
		[void],
		"payable"
	>;

	createSellOrder: TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	deposit: TypedContractMethod<[tokenAddr: AddressLike], [void], "payable">;

	depositToken: TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	depositTokenFrom: TypedContractMethod<
		[tokenAddr: AddressLike, fromAddress: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	getBalance: TypedContractMethod<[], [bigint], "view">;

	listParityToken: TypedContractMethod<
		[
			tokenAddr: AddressLike,
			parityAddr: AddressLike,
			reward: BigNumberish,
			rewardThreshold: BigNumberish
		],
		[void],
		"nonpayable"
	>;

	listToken: TypedContractMethod<
		[
			tokenAddr: AddressLike,
			reward: BigNumberish,
			rewardThreshold: BigNumberish,
			price: string
		],
		[void],
		"nonpayable"
	>;

	listingCost: TypedContractMethod<[], [bigint], "view">;

	orders: TypedContractMethod<
		[arg0: BigNumberish],
		[
			[string, string, boolean, bigint, bigint, bigint, bigint] & {
				makerAddr: string;
				tokenAddr: string;
				orderType: boolean;
				created: bigint;
				price: bigint;
				principal: bigint;
				pending: bigint;
			}
		],
		"view"
	>;

	owner: TypedContractMethod<[], [string], "view">;

	queryBalance: TypedContractMethod<
		[tokenAddr: AddressLike, isAVAX: boolean],
		[bigint],
		"view"
	>;

	settleOrders: TypedContractMethod<
		[tokenAddr: AddressLike, orderType: boolean],
		[void],
		"nonpayable"
	>;

	takeBuyOrder: TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;

	takeSellOrder: TypedContractMethod<
		[tokenAddr: AddressLike],
		[void],
		"payable"
	>;

	transferOwnership: TypedContractMethod<
		[_address: AddressLike],
		[void],
		"nonpayable"
	>;

	updateTokenBalance: TypedContractMethod<
		[tokenAddr: AddressLike],
		[void],
		"nonpayable"
	>;

	viewOrder: TypedContractMethod<
		[index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;

	viewOrderByMaker: TypedContractMethod<
		[makerAddr: AddressLike, index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;

	viewOrderByToken: TypedContractMethod<
		[tokenAddr: AddressLike, index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;

	viewPrice: TypedContractMethod<[], [bigint], "view">;

	viewToken: TypedContractMethod<
		[tokenAddr: AddressLike],
		[DexhuneExchangeBase.TokenDataModelStructOutput],
		"view"
	>;

	viewTokenByIndex: TypedContractMethod<
		[tokenNo: BigNumberish],
		[DexhuneExchangeBase.TokenDataModelStructOutput],
		"view"
	>;

	getFunction<T extends ContractMethod = ContractMethod>(
		key: string | FunctionFragment
	): T;

	getFunction(
		nameOrSignature: "assignPriceDAO"
	): TypedContractMethod<[addr: AddressLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "clearOrders"
	): TypedContractMethod<[], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "createBuyOrder"
	): TypedContractMethod<[tokenAddr: AddressLike], [void], "payable">;
	getFunction(
		nameOrSignature: "createSellOrder"
	): TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "deposit"
	): TypedContractMethod<[tokenAddr: AddressLike], [void], "payable">;
	getFunction(
		nameOrSignature: "depositToken"
	): TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "depositTokenFrom"
	): TypedContractMethod<
		[tokenAddr: AddressLike, fromAddress: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "getBalance"
	): TypedContractMethod<[], [bigint], "view">;
	getFunction(
		nameOrSignature: "listParityToken"
	): TypedContractMethod<
		[
			tokenAddr: AddressLike,
			parityAddr: AddressLike,
			reward: BigNumberish,
			rewardThreshold: BigNumberish
		],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "listToken"
	): TypedContractMethod<
		[
			tokenAddr: AddressLike,
			reward: BigNumberish,
			rewardThreshold: BigNumberish,
			price: string
		],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "listingCost"
	): TypedContractMethod<[], [bigint], "view">;
	getFunction(nameOrSignature: "orders"): TypedContractMethod<
		[arg0: BigNumberish],
		[
			[string, string, boolean, bigint, bigint, bigint, bigint] & {
				makerAddr: string;
				tokenAddr: string;
				orderType: boolean;
				created: bigint;
				price: bigint;
				principal: bigint;
				pending: bigint;
			}
		],
		"view"
	>;
	getFunction(
		nameOrSignature: "owner"
	): TypedContractMethod<[], [string], "view">;
	getFunction(
		nameOrSignature: "queryBalance"
	): TypedContractMethod<
		[tokenAddr: AddressLike, isAVAX: boolean],
		[bigint],
		"view"
	>;
	getFunction(
		nameOrSignature: "settleOrders"
	): TypedContractMethod<
		[tokenAddr: AddressLike, orderType: boolean],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "takeBuyOrder"
	): TypedContractMethod<
		[tokenAddr: AddressLike, amount: BigNumberish],
		[void],
		"nonpayable"
	>;
	getFunction(
		nameOrSignature: "takeSellOrder"
	): TypedContractMethod<[tokenAddr: AddressLike], [void], "payable">;
	getFunction(
		nameOrSignature: "transferOwnership"
	): TypedContractMethod<[_address: AddressLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "updateTokenBalance"
	): TypedContractMethod<[tokenAddr: AddressLike], [void], "nonpayable">;
	getFunction(
		nameOrSignature: "viewOrder"
	): TypedContractMethod<
		[index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;
	getFunction(
		nameOrSignature: "viewOrderByMaker"
	): TypedContractMethod<
		[makerAddr: AddressLike, index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;
	getFunction(
		nameOrSignature: "viewOrderByToken"
	): TypedContractMethod<
		[tokenAddr: AddressLike, index: BigNumberish],
		[DexhuneExchangeBase.OrderStructOutput],
		"view"
	>;
	getFunction(
		nameOrSignature: "viewPrice"
	): TypedContractMethod<[], [bigint], "view">;
	getFunction(
		nameOrSignature: "viewToken"
	): TypedContractMethod<
		[tokenAddr: AddressLike],
		[DexhuneExchangeBase.TokenDataModelStructOutput],
		"view"
	>;
	getFunction(
		nameOrSignature: "viewTokenByIndex"
	): TypedContractMethod<
		[tokenNo: BigNumberish],
		[DexhuneExchangeBase.TokenDataModelStructOutput],
		"view"
	>;

	getEvent(
		key: "AVAXTransferred"
	): TypedContractEvent<
		AVAXTransferredEvent.InputTuple,
		AVAXTransferredEvent.OutputTuple,
		AVAXTransferredEvent.OutputObject
	>;
	getEvent(
		key: "AssignedPriceDAO"
	): TypedContractEvent<
		AssignedPriceDAOEvent.InputTuple,
		AssignedPriceDAOEvent.OutputTuple,
		AssignedPriceDAOEvent.OutputObject
	>;
	getEvent(
		key: "OrderCreated"
	): TypedContractEvent<
		OrderCreatedEvent.InputTuple,
		OrderCreatedEvent.OutputTuple,
		OrderCreatedEvent.OutputObject
	>;
	getEvent(
		key: "OrderReverted"
	): TypedContractEvent<
		OrderRevertedEvent.InputTuple,
		OrderRevertedEvent.OutputTuple,
		OrderRevertedEvent.OutputObject
	>;
	getEvent(
		key: "OrderSettled"
	): TypedContractEvent<
		OrderSettledEvent.InputTuple,
		OrderSettledEvent.OutputTuple,
		OrderSettledEvent.OutputObject
	>;
	getEvent(
		key: "OrderTaken"
	): TypedContractEvent<
		OrderTakenEvent.InputTuple,
		OrderTakenEvent.OutputTuple,
		OrderTakenEvent.OutputObject
	>;
	getEvent(
		key: "TokenListed"
	): TypedContractEvent<
		TokenListedEvent.InputTuple,
		TokenListedEvent.OutputTuple,
		TokenListedEvent.OutputObject
	>;
	getEvent(
		key: "TokenTransferred"
	): TypedContractEvent<
		TokenTransferredEvent.InputTuple,
		TokenTransferredEvent.OutputTuple,
		TokenTransferredEvent.OutputObject
	>;
	getEvent(
		key: "TransferredOwnership"
	): TypedContractEvent<
		TransferredOwnershipEvent.InputTuple,
		TransferredOwnershipEvent.OutputTuple,
		TransferredOwnershipEvent.OutputObject
	>;

	filters: {
		"AVAXTransferred(uint256,address)": TypedContractEvent<
			AVAXTransferredEvent.InputTuple,
			AVAXTransferredEvent.OutputTuple,
			AVAXTransferredEvent.OutputObject
		>;
		AVAXTransferred: TypedContractEvent<
			AVAXTransferredEvent.InputTuple,
			AVAXTransferredEvent.OutputTuple,
			AVAXTransferredEvent.OutputObject
		>;

		"AssignedPriceDAO(address)": TypedContractEvent<
			AssignedPriceDAOEvent.InputTuple,
			AssignedPriceDAOEvent.OutputTuple,
			AssignedPriceDAOEvent.OutputObject
		>;
		AssignedPriceDAO: TypedContractEvent<
			AssignedPriceDAOEvent.InputTuple,
			AssignedPriceDAOEvent.OutputTuple,
			AssignedPriceDAOEvent.OutputObject
		>;

		"OrderCreated(uint256,bool,address,uint256,uint256)": TypedContractEvent<
			OrderCreatedEvent.InputTuple,
			OrderCreatedEvent.OutputTuple,
			OrderCreatedEvent.OutputObject
		>;
		OrderCreated: TypedContractEvent<
			OrderCreatedEvent.InputTuple,
			OrderCreatedEvent.OutputTuple,
			OrderCreatedEvent.OutputObject
		>;

		"OrderReverted(uint256,bool,address)": TypedContractEvent<
			OrderRevertedEvent.InputTuple,
			OrderRevertedEvent.OutputTuple,
			OrderRevertedEvent.OutputObject
		>;
		OrderReverted: TypedContractEvent<
			OrderRevertedEvent.InputTuple,
			OrderRevertedEvent.OutputTuple,
			OrderRevertedEvent.OutputObject
		>;

		"OrderSettled(uint256,bool,address,bool)": TypedContractEvent<
			OrderSettledEvent.InputTuple,
			OrderSettledEvent.OutputTuple,
			OrderSettledEvent.OutputObject
		>;
		OrderSettled: TypedContractEvent<
			OrderSettledEvent.InputTuple,
			OrderSettledEvent.OutputTuple,
			OrderSettledEvent.OutputObject
		>;

		"OrderTaken(uint256,bool,address,address,address,uint256,bool)": TypedContractEvent<
			OrderTakenEvent.InputTuple,
			OrderTakenEvent.OutputTuple,
			OrderTakenEvent.OutputObject
		>;
		OrderTaken: TypedContractEvent<
			OrderTakenEvent.InputTuple,
			OrderTakenEvent.OutputTuple,
			OrderTakenEvent.OutputObject
		>;

		"TokenListed(string,string,uint8,address,uint256)": TypedContractEvent<
			TokenListedEvent.InputTuple,
			TokenListedEvent.OutputTuple,
			TokenListedEvent.OutputObject
		>;
		TokenListed: TypedContractEvent<
			TokenListedEvent.InputTuple,
			TokenListedEvent.OutputTuple,
			TokenListedEvent.OutputObject
		>;

		"TokenTransferred(uint256,address,address)": TypedContractEvent<
			TokenTransferredEvent.InputTuple,
			TokenTransferredEvent.OutputTuple,
			TokenTransferredEvent.OutputObject
		>;
		TokenTransferred: TypedContractEvent<
			TokenTransferredEvent.InputTuple,
			TokenTransferredEvent.OutputTuple,
			TokenTransferredEvent.OutputObject
		>;

		"TransferredOwnership(address,address)": TypedContractEvent<
			TransferredOwnershipEvent.InputTuple,
			TransferredOwnershipEvent.OutputTuple,
			TransferredOwnershipEvent.OutputObject
		>;
		TransferredOwnership: TypedContractEvent<
			TransferredOwnershipEvent.InputTuple,
			TransferredOwnershipEvent.OutputTuple,
			TransferredOwnershipEvent.OutputObject
		>;
	};
}
